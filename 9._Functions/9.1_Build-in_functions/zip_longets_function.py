"""Функция zip_longest()
Как уже известно, функция zip() объединяет элементы различных последовательностей. Особенностью функции является то,
что при передаче последовательностей различной длины элементы последовательности большей длины будут отброшены.
Реализуйте функцию zip_longest(), которая принимает переменное количество позиционных аргументов,
каждый из которых является списком, и один необязательный именованный аргумент fill, имеющий значение по умолчанию None.
Функция должна объединять элементы переданных последовательностей в кортежи, аналогично функции zip(),
и возвращать в виде списка, но если последовательности имеют различную длину,
недостающие элементы последовательностей меньшей длины должны принимать значение fill.
Примечание 1. Рассмотрим первый тест со следующим вызовом:
zip_longest([1, 2, 3, 4, 5], ['a', 'b', 'c'], fill='_')
Первый список имеет длину 55, второй — 33, то есть элементам 4 и 5 из первого списка нет пар из второго списка.
В таком случае, функция должна сопоставить им значение fill, равное '_'. Итак, результатом работы функции будет список:
[(1, 'a'), (2, 'b'), (3, 'c'), (4, '_'), (5, '_')]
"""


def zip_longest(*lists, fill=None):
    max_length = len(max(lists, key=len))
    result = []
    for i in range(max_length):
        midterm = []
        for list_ in lists:
            if i < len(list_):
                midterm.append(list_[i])
            else:
                midterm.append(fill)
        result.append(tuple(midterm))
    return result


print(zip_longest([1, 2, 3, 4, 5], ['a', 'b', 'c'], fill='_'))

data = [[1, 2, 3, 4, 5], ['one', 'two', 'three'], ['I', 'II']]
print(zip_longest(*data))

data = [[1, 2, 3, 4, 5], ['one', 'two', 'three', 'four', 'five'], ['I', 'II', 'III', 'IV', 'V']]
print(zip_longest(*data))
